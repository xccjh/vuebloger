(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{462:function(t,a,s){},518:function(t,a,s){"use strict";var e=s(462);s.n(e).a},602:function(t,a,s){"use strict";s.r(a);s(518);var e=s(47),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"gzip和deflate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gzip和deflate"}},[t._v("#")]),t._v(" GZip和deflate")]),t._v(" "),s("p",[t._v("gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；deflate是一种压缩算法,是huffman编码的一种加强。")]),t._v(" "),s("p",[t._v("deflate与gzip解压的代码几乎相同，可以合成一块代码。区别仅有：deflate使用inflateInit()，而gzip使用inflateInit2()进行初始化，比 inflateInit()多一个参数: -MAX_WBITS，表示处理raw deflate数据。")]),t._v(" "),s("p",[t._v("因为gzip数据中的zlib压缩数据块没有zlib header的两个字节。使用inflateInit2时要求zlib库忽略zlib header。在zlib手册中要求windowBits为8..15，但是实际上其它范围的数据有特殊作用，见zlib.h中的注释，如负数表示raw deflate。")]),t._v(" "),s("p",[t._v("Apache的deflate变种可能也没有zlib header，需要添加假头后处理。即MS的错误deflate (raw deflate).zlib头第1字节一般是0x78, 第2字节与第一字节合起来的双字节应能被31整除，详见rfc1950。例如Firefox的zlib假头为0x7801，python zlib.compress()结果头部为0x789c。")]),t._v(" "),s("p",[t._v("deflate 是最基础的算法，是一个无专利的压缩算法，同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法，有众多开源的实现算法。gzip是使用DEFLATE进行压缩数据的另一个压缩库, 在 deflate 的 raw data 前增加了 10 个字节的 gzheader，尾部添加了 8 个字节的校验字节（可选 crc32 和 adler32） 和长度标识字节。即Gzip中使用的算法也是LZ77算法和哈夫曼编码，是单个文件内部文本信息的前后参照，共享信息实现压缩。")]),t._v(" "),s("ul",[s("li",[t._v("LZ77算法：如果文件中有两块内容相同，那么只要知道前一块的位置和大小，我们就可以确定后一块的内容。")]),t._v(" "),s("li",[t._v("哈夫曼编码：是一种可变长度编码，实现最短的文本编码。其中，出现频率高的字符串使用短编码，出现频率低的使用长编码。")])]),t._v(" "),s("h2",{attrs:{id:"brotli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#brotli"}},[t._v("#")]),t._v(" Brotli")]),t._v(" "),s("p",[t._v("Brotli最初发布于2015年，用于网络字体的离线压缩。Google软件工程师在2015年9月发布了包含通用无损数据压缩的Brotli增强版本，特别侧重于HTTP压缩。其中的编码器被部分改写以提高压缩比，编码器和解码器都提高了速度，流式API已被改进，增加更多压缩质量级别。新版本还展现了跨平台的性能改进，以及减少解码所需的内存。")]),t._v(" "),s("p",[t._v("与常见的通用压缩算法不同，Brotli使用一个预定义的120千字节字典。该字典包含超过13000个常用单词、短语和其他子字符串，这些来自一个文本和HTML文档的大型语料库。预定义的算法可以提升较小文件的压缩密度。")]),t._v(" "),s("p",[t._v("使用brotli取代deflate来对文本文件压缩通常可以增加20%的压缩密度，而压缩与解压缩速度则大致不变。")]),t._v(" "),s("p",[t._v("浏览器支持情况")]),t._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/196812783-5913d017054ae_fix732.png",alt:""}})]),t._v(" "),s("ul",[s("li",[t._v("Chrome从版本49开始支持，但是完整的支持是在版本50（2016年5月27日开始支持）。")]),t._v(" "),s("li",[t._v("Firefox从版本52开始支持。")]),t._v(" "),s("li",[t._v("IE全版本不支持，但是Edge从版本15开始支持。")]),t._v(" "),s("li",[t._v("Safari全系不支持。")]),t._v(" "),s("li",[t._v("Opera从版本44开始支持。")])]),t._v(" "),s("p",[t._v("支持Brotli压缩算法的浏览器使用的内容编码类型为br，例如以下是Chrome浏览器请求头里Accept-Encoding的值：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Accept"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Encoding"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gzip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deflate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sdch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" br\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("如果服务端支持Brotli算法，则会返回以下的响应头：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Content"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Encoding"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" br\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("温馨提示")]),t._v(" "),s("p",[t._v("需要注意的是，只有在HTTPS的情况下，浏览器才会发送br这个Accept-Encoding。")])]),t._v(" "),s("p",[t._v("Brotli的压缩率更高，意味着通过Brotli算法压缩的文件，文件大小更小，Brotli的压缩时间比gzip要多，而解压时间则相当。所以在运行中（on-the-fly）使用Brotli算法压缩文件可能并不是一个很好的方案。我们可以预先对静态文件进行压缩，然后直接提供给客户端，这样我们就避免了Brotli压缩效率低的问题，同时使用这个方式，我们可以使用压缩质量最高的等级去压缩文件，最大程度的去减小文件的大小。 另外，由于不是所有浏览器都支持Brotli算法，所以在服务端，我们需要同时提供两种文件，一个是经过Brotli压缩的文件，一个是原始文件，在浏览器不支持Brotli的情况下，我们可以使用gzip去压缩原始文件提供给客户端。")]),t._v(" "),s("h2",{attrs:{id:"sdch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sdch"}},[t._v("#")]),t._v(" SDCH")]),t._v(" "),s("p",[t._v("sdch是Shared Dictionary Compression over HTTP的缩写，即通过字典压缩算法对各个页面中相同的内容进行压缩，减少相同的内容的传输。")]),t._v(" "),s("p",[t._v("如：一个网站中一般都是共同的头部和尾部，甚至一些侧边栏也是共同的。之前的方式每个页面打开的时候这些共同的信息都要重新加载，但使用SDCH压缩方式的话，那些共同的内容只用传输一次就可以了。")]),t._v(" "),s("p",[t._v("sdch主要分为3个部分：首次请求，下载字典，之后的请求。")]),t._v(" "),s("p",[t._v("这种方式最开始的时候是Google工具栏里为IE准备的，目前Chrome已经完全支持了，不过暂时还没发现哪个网站在使用。")]),t._v(" "),s("p",[t._v("SDCH的基于以下的事实：")]),t._v(" "),s("ol",[s("li",[t._v("在HTTP的传输文件之间有大量重复冗余的数据，从服务器端一次又一次的传输到请求端。")]),t._v(" "),s("li",[t._v("服务器端可以对这些文件之间的大量相同数据建立字典。")]),t._v(" "),s("li",[t._v("客户端第一次访问时，请求字典与差异文件。之后每次访问，都只需要传输差异文件，结合本地的字典就可以还原相应文件。")])]),t._v(" "),s("h2",{attrs:{id:"在nginx上启用brotli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在nginx上启用brotli"}},[t._v("#")]),t._v(" 在Nginx上启用Brotli")]),t._v(" "),s("p",[t._v("nginx目前并不支持Brotli算法，需要使用第三方模块，例如ngx_brotli进行实现。下面是简单的安装步骤。")]),t._v(" "),s("h3",{attrs:{id:"安装及配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安装及配置"}},[t._v("#")]),t._v(" 安装及配置")]),t._v(" "),s("ol",[s("li",[t._v("下载ngx_brotli模块及其依赖：")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("   $ git clone https"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("github"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("google"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ngx_brotli\n   $ cd ngx_brotli\n   $ git submodule update "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("init\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ol",{attrs:{start:"2"}},[s("li",[t._v("编译Nginx时加入ngx_brotli模块：")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("   $ cd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("to"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nginx_source"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n   $ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("configure "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("add"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("module"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("to"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ngx_brotli\n   $ make "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" make install\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("在Nginx配置文件的http块下增加以下指令：")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("  brotli               on"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n   brotli_comp_level    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n   brotli_buffers       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n   brotli_min_length    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n   brotli_types         "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("以上是on-the-fly的配置方式，如果是要响应已经使用Brotli压缩过的文件，则使用brotli_static指令。下面是ngx_brotli模块相关指令的一些简单解析。")]),t._v(" "),s("h3",{attrs:{id:"模块指令解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块指令解析"}},[t._v("#")]),t._v(" 模块指令解析")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("brotli_static\n启用后将会检查是否存在带有br扩展的预先压缩过的文件。如果值为always，则总是使用压缩过的文件，而不判断浏览器是否支持。")])]),t._v(" "),s("li",[s("p",[t._v("brotli\n是否启用在on-the-fly方式压缩文件，启用后，将会在响应时对文件进行压缩并返回。")])]),t._v(" "),s("li",[s("p",[t._v("brotli_types\n指定对哪些内容编码类型进行压缩。text/html内容总是会被进行压缩。")])]),t._v(" "),s("li",[s("p",[t._v("brotli_buffers\n设置缓冲的数量和大小。大小默认为一个内存页的大小，也就是4k或者8k。")])]),t._v(" "),s("li",[s("p",[t._v("brotli_comp_level\n设置压缩质量等级。取值范围是0到11.")])]),t._v(" "),s("li",[s("p",[t._v("brotli_window\n设置窗口大小。")])]),t._v(" "),s("li",[s("p",[t._v("brotli_min_length\n设置需要进行压缩的最小响应大小。")])])]),t._v(" "),s("h2",{attrs:{id:"accept-encoding和content-encoding"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accept-encoding和content-encoding"}},[t._v("#")]),t._v(" Accept-Encoding和Content-Encoding")]),t._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/Snipaste_2021-12-23_15-17-14.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/231708472666307.png",alt:""}})])])}),[],!1,null,"2c2445f0",null);a.default=r.exports}}]);