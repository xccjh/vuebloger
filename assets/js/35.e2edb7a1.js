(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{457:function(a,t,s){},521:function(a,t,s){"use strict";var n=s(457);s.n(n).a},607:function(a,t,s){"use strict";s.r(t);s(521);var n=s(47),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("垃圾回收机制有两种方式，一种是引用法，一种是标记法")]),a._v(" "),s("h2",{attrs:{id:"引用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用法"}},[a._v("#")]),a._v(" 引用法")]),a._v(" "),s("p",[a._v("就是判断一个对象的引用数，引用数为0就回收，引用数大于0就不回收。请看以下代码")]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'林三心'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" age"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" obj2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" obj1\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" obj3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" obj1\n\nobj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("\nobj2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("\nobj3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/a7e937bd909f4d3fba0b232fcebae6a3_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("p",[a._v("引用法是有缺点的，下面代码执行完后，按理说obj1和obj2都会被回收，但是由于他们互相引用，各自引用数都是1，所以不会被回收，从而造成内存泄漏")]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("fn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" obj1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" obj2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  obj1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" obj2\n  obj2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" obj1\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/14651a30424942da833c0a4b66e3bfe7_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"标记法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记法"}},[a._v("#")]),a._v(" 标记法")]),a._v(" "),s("p",[a._v("标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。")]),a._v(" "),s("p",[a._v("想要判断可不可达，就不得不说可达性了，可达性是什么？就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。")]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 可达")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'林三心'")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  arr"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 林三心")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// { arr: [1, 2, 3] }")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [1, 2, 3]")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("fn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" age "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 不可达")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// undefined")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/d4413c72899b4d1485e71da2bfc5ae24_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("p",[a._v("GC其实不止这两个算法，接下来我们详细介绍v8的垃圾回收机制。")]),a._v(" "),s("h2",{attrs:{id:"javascript内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript内存管理"}},[a._v("#")]),a._v(" JavaScript内存管理")]),a._v(" "),s("p",[a._v("其实JavaScript内存的流程很简单，分为3步：")]),a._v(" "),s("ol",[s("li",[a._v("分配给使用者所需的内存")]),a._v(" "),s("li",[a._v("使用者拿到这些内存，并使用内存")]),a._v(" "),s("li",[a._v("使用者不需要这些内存了，释放并归还给系统")])]),a._v(" "),s("p",[a._v("那么这些使用者是谁呢？举个例子：")]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" num "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'林三心'")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'林三心'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\nobj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'林胖子'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("上面这些num，str，obj就是就是使用者，我们都知道，JavaScript数据类型分为基础数据类型和引用数据类型:")]),a._v(" "),s("ul",[s("li",[a._v("基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问")]),a._v(" "),s("li",[a._v("引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问")])]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/787175566e294cdd9f063192ab02ab0d_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("ul",[s("li",[a._v("由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的")]),a._v(" "),s("li",[a._v("由于堆内存所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存")])]),a._v(" "),s("h2",{attrs:{id:"为啥要垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为啥要垃圾回收"}},[a._v("#")]),a._v(" 为啥要垃圾回收")]),a._v(" "),s("p",[a._v("在Chrome中，V8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制呢？")]),a._v(" "),s("p",[a._v("表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景\n深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）")]),a._v(" "),s("p",[a._v("前面说到栈内的内存，操作系统会自动进行内存分配和内存释放，而堆中的内存，由JS引擎（如Chrome的V8）手动进行释放，当我们的代码没有按照正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露），从而使得浏览器占用的内存不断增加，进而导致JavaScript和应用、操作系统性能下降。")]),a._v(" "),s("h2",{attrs:{id:"v8的垃圾回收算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8的垃圾回收算法"}},[a._v("#")]),a._v(" V8的垃圾回收算法")]),a._v(" "),s("h3",{attrs:{id:"分代回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[a._v("#")]),a._v(" 分代回收")]),a._v(" "),s("p",[a._v("在JavaScript中，对象存活周期分为两种情况")]),a._v(" "),s("ul",[s("li",[a._v("存活周期很短：经过一次垃圾回收后，就被释放回收掉")]),a._v(" "),s("li",[a._v("存活周期很长：经过多次垃圾回收后，他还存在，赖着不走")])]),a._v(" "),s("p",[a._v("那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？")]),a._v(" "),s("p",[a._v("对于这个问题，V8做了分代回收的优化方法，通俗点说就是：V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/5d027d5f92d14438952c98e0cf150a47_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("p",[a._v("新生代通常只有1-8M的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收")]),a._v(" "),s("ul",[s("li",[a._v("副垃圾回收器 + Scavenge算法：主要负责新生代的垃圾回收")]),a._v(" "),s("li",[a._v("主垃圾回收器 + Mark-Sweep && Mark-Compact算法：主要负责老生代的垃圾回收")])]),a._v(" "),s("ol",[s("li",[a._v("新生代\n在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用Scavenge算法进行垃圾回收，Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。")])]),a._v(" "),s("p",[a._v("Scavange算法将新生代堆分为两部分，分别叫from-space和to-space，工作方式也很简单，就是将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用。")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/85513f5cc29c4c50829ca24a34ecff3c_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("p",[a._v("具体步骤为以下4步：")]),a._v(" "),s("ul",[s("li",[a._v("标记活动对象和非活动对象")]),a._v(" "),s("li",[a._v("复制from-space的活动对象到to-space中并进行排序")]),a._v(" "),s("li",[a._v("清除from-space中的非活动对象")]),a._v(" "),s("li",[a._v("将from-space和to-space进行角色互换，以便下一次的Scavenge算法垃圾回收")])]),a._v(" "),s("p",[a._v("那么，垃圾回收器是怎么知道哪些对象是活动对象，哪些是非活动对象呢？")]),a._v(" "),s("p",[a._v("这就要不得不提一个东西了——可达性。什么是可达性呢？就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。")]),a._v(" "),s("p",[a._v("新生代中的对象什么时候变成老生代的对象？")]),a._v(" "),s("p",[a._v("在新生代中，还进一步进行了细分。分为nursery子代和intermediate子代两个区域，一个对象第一次分配内存时会被分配到新生代中的nursery子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到intermediate子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升")]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("老生代\n新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用Scavenge算法，为啥呢，有以下原因：")])]),a._v(" "),s("ul",[s("li",[a._v("Scavenge算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低。")]),a._v(" "),s("li",[a._v("Scavenge算法是以空间换时间的算法，老生代是内存很大的空间，如果使用Scavenge算法，空间资源非常浪费，得不偿失啊。")])]),a._v(" "),s("p",[a._v("所以老生代里使用了Mark-Sweep算法(标记清理)和Mark-Compact算法(标记整理)")]),a._v(" "),s("blockquote",[s("p",[a._v("Mark-Sweep(标记清理)")])]),a._v(" "),s("p",[a._v("Mark-Sweep分为两个阶段，标记和清理阶段，之前的Scavenge算法也有标记和清理，但是Mark-Sweep算法跟Scavenge算法的区别是，后者需要复制后再清理，前者不需要，Mark-Sweep直接标记活动对象和非活动对象之后，就直接执行清理了。")]),a._v(" "),s("ul",[s("li",[a._v("标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记")]),a._v(" "),s("li",[a._v("清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象")])]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/e8767d07d348429d8205e33c77637c0f_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("p",[a._v("由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多零零散散的空位。")]),a._v(" "),s("blockquote",[s("p",[a._v("Mark-Compact(标记整理)")])]),a._v(" "),s("p",[a._v("Mark-Sweep算法执行垃圾回收之后，留下了很多零零散散的空位，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从零零散散的空位中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是Mark-Sweep算法的一个缺点")]),a._v(" "),s("p",[a._v("这个时候Mark-Compact算法出现了，他是Mark-Sweep算法的加强版，在Mark-Sweep算法的基础上，加上了整理阶段，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/f7da553309a04432ba93840a1c06ca36_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"全停顿-stop-the-world"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全停顿-stop-the-world"}},[a._v("#")]),a._v(" 全停顿(Stop-The-World)")]),a._v(" "),s("p",[a._v("说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为全停顿")]),a._v(" "),s("p",[a._v("由于新生代空间小，并且存活对象少，再配合Scavenge算法，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了卡顿现象。")]),a._v(" "),s("h3",{attrs:{id:"orinoco优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#orinoco优化"}},[a._v("#")]),a._v(" Orinoco优化")]),a._v(" "),s("p",[a._v("orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。")]),a._v(" "),s("ol",[s("li",[a._v("增量标记(Incremental marking)\n咱们前面不断强调了先标记，后清除，而增量标记就是在标记这个阶段进行了优化。我举个生动的例子：路上有很多垃圾，害得路人都走不了路，需要清洁工打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。")])]),a._v(" "),s("p",[a._v("大家把上面例子里，清洁工清理垃圾的过程——标记过程，路人——JS代码，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS代码运行一段，从而提高效率")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/a5719b8cec604c98b5d55a39df776fb7_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("惰性清理(Lazy sweeping)\n上面说了，增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理")])]),a._v(" "),s("p",[a._v("整理标记和惰性清理的出现，大大改善了全停顿现象。但是问题也来了：增量标记是标记一点，JS运行一段，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成对象引用改变，标记错误现象。这就需要使用写屏障技术来记录这些引用关系的变化")]),a._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[a._v("并发(Concurrent)\n并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/204846e6d5614529b71bc67114c2b6df_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("并行\n并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/d55ad43196a34c8b996aa21f2e1dabf7_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"v8当前的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8当前的垃圾回收机制"}},[a._v("#")]),a._v(" V8当前的垃圾回收机制")]),a._v(" "),s("p",[a._v("2011年，V8应用了增量标记机制。直至2018年，Chrome64和Node.js V10启动并发标记（Concurrent），同时在并发的基础上添加并行（Parallel）技术，使得垃圾回收时间大幅度缩短。")]),a._v(" "),s("h3",{attrs:{id:"副垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[a._v("#")]),a._v(" 副垃圾回收器")]),a._v(" "),s("p",[a._v("V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/ca66013ea62f4637bd57744a5e62326f_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"主垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[a._v("#")]),a._v(" 主垃圾回收器")]),a._v(" "),s("p",[a._v("V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。")]),a._v(" "),s("p",[a._v("当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。")]),a._v(" "),s("p",[s("img",{attrs:{src:"/vuebloger/img/post/97a854ba9a464ba8adf143a5612ad91c_tplv-k3u1fbpfcp-watermark.awebp",alt:""}})])])}),[],!1,null,"1875ede8",null);t.default=r.exports}}]);